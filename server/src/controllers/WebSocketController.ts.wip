import { Server, Socket } from 'socket.io';
import { createHash, randomBytes } from 'crypto';
import { 
  GameEvent, 
  GameEventType,
  MoveRequestEvent,
  DuelAllocationEvent,
  RetreatSelectionEvent, 
  AuthResponseEvent,
  BPCommitmentEvent,
  BPRevealEvent,
  StateSyncRequestEvent,
  GameResignEvent,
  GameOfferDrawEvent,
  GameRespondDrawEvent,
  ChatMessageEvent,
  ReconnectionEvent
} from '@gambit-chess/shared';
import { IEventDispatcher } from '../interfaces/IEventDispatcher';
import { GameManager } from '../services/GameManager';
import { PlayerSessionManager } from '../managers/PlayerSessionManager';

/**
 * WebSocket controller for handling real-time game communication
 * Implements the event dispatcher interface to connect WebSocket events with game logic
 */
export class WebSocketController implements IEventDispatcher {
  private io: Server;
  private gameManager: GameManager;
  private playerSessionManager: PlayerSessionManager;
  private connections: Map<string, Socket> = new Map();
  private challenges: Map<string, { challenge: string, timestamp: number }> = new Map();
  private commitments: Map<string, { commitment: string, timestamp: number }> = new Map();
  
  /**
   * Create a new WebSocket controller
   * @param io Socket.IO server instance
   * @param gameManager Game manager service
   * @param playerSessionManager Player session manager
   */
  constructor(io: Server, gameManager: GameManager, playerSessionManager: PlayerSessionManager) {
    this.io = io;
    this.gameManager = gameManager;
    this.playerSessionManager = playerSessionManager;
    this.setupSocketHandlers();
  }
  
  /**
   * Initialize WebSocket connection handlers
   */
  private setupSocketHandlers(): void {
    this.io.on('connection', (socket: Socket) => {
      console.log(`New connection: ${socket.id}`);
      
      // Send authentication challenge
      const challenge = this.generateChallenge();
      this.challenges.set(socket.id, { 
        challenge, 
        timestamp: Date.now() 
      });
      
      socket.emit(GameEventType.AUTH_CHALLENGE, {
        challenge,
        timestamp: Date.now()
      });
      
      // Set up event handlers
      this.setupEventHandlers(socket);
      
      // Handle disconnection
      socket.on('disconnect', () => {
        this.handleDisconnect(socket);
      });
    });
  }
  
  /**
   * Set up event handlers for a socket connection
   * @param socket Socket connection
   */
  private setupEventHandlers(socket: Socket): void {
    // Authentication
    socket.on(GameEventType.AUTH_RESPONSE, (event: AuthResponseEvent) => {
      this.handleAuthentication(socket, event);
    });
    
    // Connection ping/heartbeat
    socket.on(GameEventType.CONNECTION_PING, (event: any) => {
      socket.emit(GameEventType.CONNECTION_PONG, {
        timestamp: Date.now(),
        echo: event.payload?.timestamp || Date.now()
      });
    });
    
    // Reconnection
    socket.on(GameEventType.CONNECTION_RECONNECT, (event: ReconnectionEvent) => {
      this.handleReconnection(socket, event);
    });
    
    // The following events are only processed after authentication
    
    // Game events - authenticated via middleware
    socket.on(GameEventType.MOVE_REQUESTED, (event: MoveRequestEvent) => {
      this.validateAuthentication(socket, () => {
        this.gameManager.processMove(event.gameId, event.payload);
      });
    });
    
    // Duel events
    socket.on(GameEventType.DUEL_COMMITMENT, (event: BPCommitmentEvent) => {
      this.validateAuthentication(socket, () => {
        const playerId = this.getPlayerIdFromSocket(socket);
        if (playerId) {
          this.commitments.set(playerId, {
            commitment: event.payload.commitment,
            timestamp: Date.now()
          });
          // Check if both players have committed
          this.gameManager.checkCommitments(event.gameId);
        }
      });
    });
    
    socket.on(GameEventType.DUEL_REVEAL, (event: BPRevealEvent) => {
      this.validateAuthentication(socket, () => {
        const playerId = this.getPlayerIdFromSocket(socket);
        if (playerId) {
          const commitment = this.commitments.get(playerId);
          if (commitment) {
            // Verify commitment
            const calculatedCommitment = this.calculateCommitment(
              event.payload.allocation,
              event.payload.nonce
            );
            
            if (calculatedCommitment === commitment.commitment) {
              // Valid commitment
              this.gameManager.processBPAllocation(event.gameId, {
                bp: event.payload.allocation
              }, playerId);
            } else {
              // Invalid commitment
              socket.emit(GameEventType.ERROR, {
                code: 'INVALID_COMMITMENT',
                message: 'Invalid BP allocation commitment'
              });
            }
          }
        }
      });
    });
    
    socket.on(GameEventType.DUEL_ALLOCATE, (event: DuelAllocationEvent) => {
      this.validateAuthentication(socket, () => {
        const playerId = this.getPlayerIdFromSocket(socket);
        this.gameManager.processBPAllocation(event.gameId, event.payload, playerId);
      });
    });
    
    // Retreat events
    socket.on(GameEventType.RETREAT_SELECTED, (event: RetreatSelectionEvent) => {
      this.validateAuthentication(socket, () => {
        this.gameManager.processRetreatSelection(event.gameId, event.payload);
      });
    });
    
    // State sync
    socket.on(GameEventType.STATE_SYNC_REQUEST, (event: StateSyncRequestEvent) => {
      this.validateAuthentication(socket, () => {
        const playerId = this.getPlayerIdFromSocket(socket);
        if (playerId) {
          this.gameManager.sendGameState(event.gameId, playerId);
        }
      });
    });
    
    // Game control
    socket.on(GameEventType.GAME_RESIGN, (event: GameResignEvent) => {
      this.validateAuthentication(socket, () => {
        const playerId = this.getPlayerIdFromSocket(socket);
        this.gameManager.processResign(event.gameId, playerId);
      });
    });
    
    socket.on(GameEventType.GAME_OFFER_DRAW, (event: GameOfferDrawEvent) => {
      this.validateAuthentication(socket, () => {
        const playerId = this.getPlayerIdFromSocket(socket);
        this.gameManager.processDrawOffer(event.gameId, playerId);
      });
    });
    
    socket.on(GameEventType.GAME_RESPOND_DRAW, (event: GameRespondDrawEvent) => {
      this.validateAuthentication(socket, () => {
        const playerId = this.getPlayerIdFromSocket(socket);
        this.gameManager.processDrawResponse(event.gameId, event.payload, playerId);
      });
    });
    
    // Chat
    socket.on(GameEventType.CHAT_MESSAGE, (event: ChatMessageEvent) => {
      this.validateAuthentication(socket, () => {
        const playerId = this.getPlayerIdFromSocket(socket);
        // Sanitize message content before processing
        const sanitizedMessage = this.sanitizeMessage(event.payload.message);
        const sanitizedEvent = {
          ...event,
          payload: {
            ...event.payload,
            message: sanitizedMessage
          }
        };
        this.gameManager.processChatMessage(event.gameId, sanitizedEvent.payload, playerId);
      });
    });
  }
  
  /**
   * Handle authentication response
   * @param socket Socket connection
   * @param event Authentication response event
   */
  private handleAuthentication(socket: Socket, event: AuthResponseEvent): void {
    const challengeData = this.challenges.get(socket.id);
    if (!challengeData) {
      socket.emit(GameEventType.AUTH_RESULT, {
        success: false,
        error: 'No challenge found'
      });
      return;
    }
    
    // Verify challenge response
    // In a real implementation, this would verify the signature using JWT or similar
    // For simplicity, we're using a simple token matching approach
    const playerId = this.playerSessionManager.getPlayerIdByToken(event.payload.token);
    if (playerId) {
      // Store connection for this player
      this.connections.set(playerId, socket);
      
      // Associate socket with player ID
      socket.data.playerId = playerId;
      
      // Clean up challenge
      this.challenges.delete(socket.id);
      
      // Send success response
      socket.emit(GameEventType.AUTH_RESULT, {
        success: true,
        playerId,
        gameId: this.playerSessionManager.getGameIdByPlayerId(playerId)
      });
      
      // Send initial game state if available
      const gameId = this.playerSessionManager.getGameIdByPlayerId(playerId);
      if (gameId) {
        this.gameManager.sendGameState(gameId, playerId);
      }
    } else {
      socket.emit(GameEventType.AUTH_RESULT, {
        success: false,
        error: 'Invalid token'
      });
    }
  }
  
  /**
   * Handle reconnection request
   * @param socket Socket connection
   * @param event Reconnection event
   */
  private handleReconnection(socket: Socket, event: ReconnectionEvent): void {
    const playerId = event.payload.playerId;
    const token = event.payload.token;
    
    // Verify token
    if (this.playerSessionManager.validatePlayerToken(playerId, token)) {
      // Update connection
      this.connections.set(playerId, socket);
      
      // Associate socket with player ID
      socket.data.playerId = playerId;
      
      // Send reconnection confirmation
      socket.emit(GameEventType.CONNECTION_STATUS, {
        status: 'connected',
        playerId
      });
      
      // Send current game state
      const gameId = this.playerSessionManager.getGameIdByPlayerId(playerId);
      if (gameId) {
        this.gameManager.sendGameState(gameId, playerId);
        
        // Notify other players
        this.gameManager.notifyPlayerReconnected(gameId, playerId);
      }
    } else {
      socket.emit(GameEventType.CONNECTION_STATUS, {
        status: 'disconnected',
        playerId
      });
    }
  }
  
  /**
   * Handle socket disconnection
   * @param socket Socket connection
   */
  private handleDisconnect(socket: Socket): void {
    console.log(`Disconnection: ${socket.id}`);
    
    // Clean up challenge if exists
    this.challenges.delete(socket.id);
    
    // Get player ID from socket
    const playerId = socket.data.playerId;
    if (playerId) {
      // Remove connection
      this.connections.delete(playerId);
      
      // Notify game manager
      const gameId = this.playerSessionManager.getGameIdByPlayerId(playerId);
      if (gameId) {
        this.gameManager.notifyPlayerDisconnected(gameId, playerId);
      }
    }
  }
  
  /**
   * Validate that the socket is authenticated
   * @param socket Socket connection
   * @param callback Callback to execute if authenticated
   */
  private validateAuthentication(socket: Socket, callback: () => void): void {
    if (socket.data.playerId) {
      callback();
    } else {
      socket.emit(GameEventType.ERROR, {
        code: 'AUTHENTICATION_REQUIRED',
        message: 'Authentication required'
      });
    }
  }
  
  /**
   * Get player ID from socket data
   * @param socket Socket connection
   * @returns Player ID or undefined
   */
  private getPlayerIdFromSocket(socket: Socket): string | undefined {
    return socket.data.playerId;
  }
  
  /**
   * Generate a random challenge for authentication
   * @returns Random challenge string
   */
  private generateChallenge(): string {
    return randomBytes(32).toString('hex');
  }
  
  /**
   * Calculate commitment hash for BP allocation
   * @param allocation BP allocation
   * @param nonce Random nonce
   * @returns Commitment hash
   */
  private calculateCommitment(allocation: number, nonce: string): string {
    return createHash('sha256')
      .update(`${allocation}:${nonce}`)
      .digest('hex');
  }
  
  /**
   * Sanitize message content to prevent injection
   * @param message Raw message
   * @returns Sanitized message
   */
  private sanitizeMessage(message: string): string {
    // Basic sanitization - would be more comprehensive in production
    return message
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .trim()
      .slice(0, 500); // Limit message length
  }
  
  /**
   * IEventDispatcher implementation
   */
  
  /**
   * Dispatch event to a specific player
   * @param playerId Player ID
   * @param eventName Event name
   * @param data Event data
   */
  public dispatchToPlayer(playerId: string, eventName: string, data: any): void {
    const socket = this.connections.get(playerId);
    if (socket) {
      socket.emit(eventName, data);
    }
  }
  
  /**
   * Dispatch event to all players in a game
   * @param gameId Game ID
   * @param eventName Event name
   * @param data Event data
   */
  public dispatchToGame(gameId: string, eventName: string, data: any): void {
    const playerIds = this.playerSessionManager.getPlayerIdsByGameId(gameId);
    playerIds.forEach(playerId => {
      this.dispatchToPlayer(playerId, eventName, data);
    });
  }
  
  /**
   * Dispatch event to all spectators of a game
   * @param gameId Game ID
   * @param eventName Event name
   * @param data Event data
   */
  public dispatchToSpectators(gameId: string, eventName: string, data: any): void {
    // Get room for spectators
    const room = `spectator:${gameId}`;
    this.io.to(room).emit(eventName, data);
  }
  
  /**
   * Dispatch different events to white and black players
   * @param gameId Game ID
   * @param eventName Event name
   * @param whiteData Data for white player
   * @param blackData Data for black player
   */
  public dispatchToPlayers(gameId: string, eventName: string, whiteData: any, blackData: any): void {
    const playerIds = this.playerSessionManager.getPlayerIdsByGameId(gameId);
    const whitePlayers = playerIds.filter(id => 
      this.playerSessionManager.getPlayerColor(id)?.value === 'w'
    );
    const blackPlayers = playerIds.filter(id => 
      this.playerSessionManager.getPlayerColor(id)?.value === 'b'
    );
    
    // Send to white players
    whitePlayers.forEach(id => {
      this.dispatchToPlayer(id, eventName, whiteData);
    });
    
    // Send to black players
    blackPlayers.forEach(id => {
      this.dispatchToPlayer(id, eventName, blackData);
    });
  }
  
  /**
   * Dispatch event to everyone connected to a game
   * @param gameId Game ID
   * @param eventName Event name
   * @param data Event data
   */
  public dispatchToAll(gameId: string, eventName: string, data: any): void {
    this.dispatchToGame(gameId, eventName, data);
    this.dispatchToSpectators(gameId, eventName, data);
  }
  
  /**
   * Register a connection for a player
   * @param playerId Player ID
   * @param connection Socket connection
   */
  public registerConnection(playerId: string, connection: Socket): void {
    this.connections.set(playerId, connection);
    connection.data.playerId = playerId;
  }
  
  /**
   * Unregister a connection for a player
   * @param playerId Player ID
   */
  public unregisterConnection(playerId: string): void {
    this.connections.delete(playerId);
  }
} 